04 Nov 2024 0800 hrs

Monday

we will note down all the concepts that we are learning in this project

let's start with what scares us the most:
async programming in rust


Imagine you're playing a video game and need to load a big map.
With a normal function, the game would freeze until loading finishes.
But with async, the game keeps running while the map loads in the background!

That's why we use async here - reading ZIP files can be slow,
but we don't want to freeze the whole program while we wait.
The async function lets other code run while we're reading the ZIP.

Normal:     Async:
  [WAIT]      [Other]
  [WAIT]  vs  [Other]
  [WAIT]      [Other]
  [Done]      [Done]


Explain the tokio spawn_blocking function using this example - what does this code do?

```rust
        let analysis = tokio::task::spawn_blocking(move || -> Result<ZipAnalysis> {
        //  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        //  â”‚ Store   â”‚  â”‚ Create new thread  â”‚  â”‚ Closure that will run     â”‚
        //  â”‚ result  â”‚  â”‚ for blocking work  â”‚  â”‚ in the new thread         â”‚
        //  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        //                                              â†“
        //                                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        //                                       â”‚ move = take     â”‚
        //                                       â”‚ ownership of    â”‚
        //                                       â”‚ used variables  â”‚
        //                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        }).await??;  
        //  â†‘   â†‘â†‘
        //  â”‚   â”‚â””â”€ Handle Result from ZipAnalysis
        //  â”‚   â””â”€â”€ Handle thread errors
        //  â””â”€â”€â”€â”€â”€â”€ Wait for thread to finish
```

In tokio:
- task is a module that provides task management utilities
- spawn_blocking is a function that runs blocking code in a dedicated thread pool
so it doesn't block tokio's async event loop

now we will store in analysis variable the result of the spawn_blocking 

but what is spawn_blocking - is it a function or a closure?

spawn_blocking is a function that takes a closure as an argument and returns a future

Closures vs Functions:
Functions:
  fn add(x: i32) { x + 1 }
  - Standalone, can't capture variables
  - Must declare types

Closures:
  let add = |x| { x + 1 };
  - Can capture variables from scope i.e. it can use variables which are not passed to it as parameters
  - Type inference
  - Syntax: |params| { body }

Here we use a closure because:
1. We need to capture zip_path from outer scope
2. It's a one-off task specific to this context
3. We need move semantics to transfer ownership to new thread

A thread pool is like a team of workers waiting for jobs
Instead of creating/destroying threads for each task (expensive!)
The pool keeps some threads ready to handle work as it comes in
When one worker finishes, they go back to the pool to wait for the next job
This keeps the main async thread free to handle other tasks

In this example:
1. spawn_blocking creates new thread to read ZIP file (blocking I/O)
2. move closure captures zip_path and owns it in new thread
3. Returns Result<ZipAnalysis> when done
4. First ? handles JoinError if thread panics
5. Second ? handles Result from ZipAnalysis




The closure part is: move || -> Result<ZipAnalysis>
  â”Œâ”€â”€â”€â”€â” â”Œâ” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚moveâ”‚ â”‚â”‚ â”‚Return type          â”‚ 
  â”‚    â”‚ â”‚â”‚ â”‚(Result<ZipAnalysis>)â”‚
  â””â”€â”€â”€â”€â”˜ â””â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘     â†‘
    â”‚     â””â”€ Empty params list ||
    â””â”€ Keyword to take ownership

what does an empty params list mean for a closure?

it means the closure takes no parameters - it will just execute its body using only captured variables from the outer scope. in our case, it uses zip_path which it captured, but doesn't need any additional inputs.

```rust
// Example 1: Capturing Environment
let x = 10;
let add_to_x = |y| y + x; // Closure captures x from the environment
println!("Result: {}", add_to_x(5)); // Output: Result: 15

```

```rust
// Example 2: Using Closures in Iterators
let numbers = vec![1, 2, 3, 4, 5];
let doubled: Vec<i32> = numbers.iter().map(|&x| x * 2).collect(); // Closure doubles each element
println!("Doubled: {:?}", doubled); // Output: Doubled: [2, 4, 6, 8, 10]

// Why closures were needed:
// Closures allow us to define inline, anonymous functions that can capture variables from their surrounding scope.
// In this example, the closure captures each element of the iterator and doubles it, making the code concise and expressive.
// Without closures, we would need to define a separate function to achieve the same result, which would be less convenient and less readable.

```



Future explained:
spawn_blocking returns a JoinHandle<Result<ZipAnalysis>>

JoinHandle is a type from tokio that represents an asynchronous task running in the background. It lets us:
- Check if task completed
- Get result when done
- Cancel task if needed
- Handle errors if task panics

JoinHandle isn't shown in the closure syntax because it's the implicit return type of spawn_blocking itself. The closure syntax only shows what WE provide (the move closure returning Result<ZipAnalysis>). spawn_blocking then wraps our closure's return type in JoinHandle automatically.

Think of it like this:
spawn_blocking: Fn(closure) -> JoinHandle<closure_return_type>
In our case:
spawn_blocking: Fn(closure) -> JoinHandle<Result<ZipAnalysis>>

Result<ZipAnalysis> means the task will either return:
- Ok(ZipAnalysis) - Success with ZIP analysis data
- Err(e) - An error occurred during analysis

Is Result<ZipAnalysis> an enum?

Yes! Result is an enum with two variants:
- Ok(T): Contains successful value of type T
- Err(E): Contains error value of type E

So Result<ZipAnalysis> means:
- Ok(ZipAnalysis): Success case with ZIP analysis
- Err(anyhow::Error): Error case with error details

This lets us handle both success and failure cases explicitly.

JoinHandle is a Future that resolves when thread completes
Like an IOU that will eventually contain our analysis
IOU = "I Owe You" - a promise to deliver something later
Just like a real IOU promises future payment, 
this promises future data when the thread finishes
We .await it to get the actual value when ready


How Async Works in Our ZIP Reader phase 1 (exp003) (ELI15)
----------------------------------------

Current Implementation:
```
Main Thread        Worker Thread
    |                  |
    |--spawn_blocking->|
    |                  |--read ZIP-->
    |                  |--process-->
    |<--results--------|
    |
    |--write report-->
```

Is it actually faster? Not really! Here's why:
1. We're still using just ONE thread to read the ZIP
2. We're still using just ONE thread to write the report
3. The async part just keeps our main thread free while waiting

It's like having a helper do your homework while you do something else - the homework doesn't get done faster, but at least you're not stuck waiting!




Making it Actually Parallel
-------------------------

Option 1: Chunk-based Reading
```rust
let chunks = split_zip_into_chunks(zip_file, 4);  // Split into 4 parts
let mut tasks = Vec::new();

for chunk in chunks {
    //  |       |       |
    //  |       |       Loop variable (each chunk)
    //  |       Collection to iterate over
    //  Loop keyword
    tasks.push(tokio::spawn(async move {
    //  |     |   |     |       |     |
    //  |     |   |     |       |     Move ownership of chunk into async block
    //  |     |   |     |       Async block
    //  |     |   |     Spawn a new task
    //  |     |   Tokio runtime
    //  |     Push task handle into tasks vector
    //  Tasks vector
        process_chunk(chunk)
    //  |           |
    //  |           Function to process each chunk
    //  Pass chunk to function
    }));
    //  | |
    //  | Close async block
    //  Close spawn function
}

let results = futures::future::join_all(tasks).await;
```

Option 2: Parallel File Processing
```rust
// Process multiple files in parallel
let mut tasks = Vec::new();
for i in 0..archive.len() {
    let mut archive_clone = archive.clone();  // Need thread-safe ZIP reader
    tasks.push(tokio::spawn(async move {
        process_file(archive_clone.by_index(i))
    }));
}
```

Option 3: Pipeline Processing
```
Reader Thread -> Processor Thread -> Writer Thread
     |                  |                |
  read chunk       analyze files     write report
     |                  |                |
  read next         analyze next      write next
```

Challenges with Parallelization:
1. ZIP format is sequential - hard to read chunks randomly
2. Need thread-safe ZIP reader (current zip crate isn't)
3. Must maintain file order in final report
4. Risk of disk I/O becoming bottleneck

Potential Solutions:
1. Use rayon for parallel processing
2. Implement custom thread-safe ZIP reader
3. Memory map large ZIP files
4. Use buffered reading/writing

Example with rayon:
```rust
use rayon::prelude::*;

let results: Vec<FileInfo> = archive
    .file_names()
    .par_iter()  // Parallel iterator
    .map(|name| process_file(name))
    .collect();
```
============


Remember: True parallelization requires:
1. Thread-safe data structures
2. Careful coordination
3. Handling out-of-order results
4. Managing system resources

The current async implementation is more about "not blocking" than "going faster". 

For real speed gains, we'd need to rework how we handle the ZIP data!


Rayon + Tokio: The Dynamic Duo! ğŸ¦¸â€â™‚ï¸ğŸ¦¸â€â™€ï¸
--------------------------------

"Think of Tokio as a master coordinator and Rayon as a team of super-fast workers.
Together, they can make your ZIP processing zoom! ğŸƒâ€â™‚ï¸ğŸ’¨"

How They Work Together:
```
Tokio (Async)     Rayon (Parallel)
    ğŸ®               ğŸ‘¥ğŸ‘¥ğŸ‘¥ğŸ‘¥
    â”‚               Workers Pool
    â”‚                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         Cooperation
```

Processing Flow:
```
                   â”Œâ”€â”€â”€ Worker1 â”€â”€â”€â”
ZIP File â”€â”€â–º Tokio â”œâ”€â”€â”€ Worker2 â”€â”€â”€â”¤ â”€â”€â–º Results
   ğŸ“¦        ğŸ®    â”œâ”€â”€â”€ Worker3 â”€â”€â”€â”¤     ğŸ“Š
                   â””â”€â”€â”€ Worker4 â”€â”€â”€â”˜
```



Example Implementation:
```rust
use rayon::prelude::*;
use tokio;

async fn process_zip(path: PathBuf) -> Result<ZipAnalysis> {
    // Tokio handles the async file operations
    let file_data = tokio::fs::read(&path).await?;
    
    // Spawn blocking for CPU-intensive work with Rayon
    tokio::task::spawn_blocking(move || {
        // Rayon parallelizes the processing
        let results: Vec<FileInfo> = archive_entries
            .par_iter()           // ğŸ‘¥ Parallel iterator
            .map(|entry| {        // ğŸ”„ Process each entry
                process_entry(entry)
            })
            .collect();           // ğŸ“¦ Gather results

        Ok(ZipAnalysis::new(results))
    }).await?
}
```

Memory Layout:
```
Heap Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ZIP Data     â”‚ â—„â”€â”€ Multiple Rayon workers
â”‚ â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”   â”‚     read from same data
â”‚ â”‚ 1 â”‚ 2 â”‚ 3 â”‚   â”‚     (zero-copy sharing)
â””â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Thread Layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Main Thread â”‚ Tokio runtime
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   â”‚ Rayon â”‚ Thread pool
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”Œâ”€â”€â”´â”€â”€â”
    â”‚ /// â”‚ Worker threads
    â””â”€â”€â”€â”€â”€â”˜
```

Performance Benefits:
```
Single Thread:   [=====>] 100s
Tokio Only:     [=====>] 100s
Rayon Only:     [===>]    60s
Tokio + Rayon:  [=>]      30s*

* Theoretical best case with:
  - Multiple CPU cores
  - Fast disk I/O
  - Large ZIP files
```

Best Practices:
1. Use Tokio for ğŸ“¥ I/O Operations:
   ```rust
   // Let Tokio handle file operations
   let file = tokio::fs::File::open(path).await?;
   ```

2. Use Rayon for ğŸ§® CPU-Heavy Work:
   ```rust
   // Let Rayon handle parallel processing
   entries.par_iter().for_each(|e| process(e));
   ```

3. Combine Their Powers:
   ```rust
   // Tokio manages async flow
   tokio::spawn(async move {
       // Rayon handles parallel computation
       let results = pool.install(|| {
           data.par_iter()
               .map(|item| heavy_compute(item))
               .collect()
       });
   });
   ```

Remember:
- ğŸ® Tokio = Async I/O (waiting for files)
- ğŸ‘¥ Rayon = Parallel CPU (processing data)
- ğŸ¤ Together = Best of both worlds!

Warning Signs You Need This:
```
Bad Signs        Good Signs
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CPU 25%  â”‚    â”‚ CPU 100% â”‚
â”‚ Waiting  â”‚    â”‚ All Coresâ”‚
â”‚ Single   â”‚    â”‚ Large    â”‚
â”‚ Thread   â”‚    â”‚ Files    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

