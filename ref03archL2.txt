# ZIP Analyzer Implementation Blueprint - MVP Version üìù

## 1. ZIP Format Constants and Types
```rust
// Essential ZIP format signatures
const ZIP_LOCAL_HEADER_SIGNATURE: u32    = 0x04034b50;
const ZIP_CENTRAL_DIR_SIGNATURE: u32     = 0x02014b50;
const ZIP_END_CENTRAL_DIR_SIGNATURE: u32 = 0x06054b50;

// Critical size constants
const MIN_EOCD_SIZE: u32 = 22;          // Minimum EOCD record size
const MAX_COMMENT_SIZE: u16 = 0xFFFF;    // 64KB max comment

// Basic compression methods
const STORED: u16 = 0;
const DEFLATED: u16 = 8;

// Size and format limits
const MAX_FILE_SIZE: u64 = 0xFFFFFFFF;  // 4GB limit (ZIP32)
const MAX_FILE_COUNT: u32 = 0xFFFF;     // 65,535 files (ZIP32)
const CHUNK_SIZE: usize = 4 * 1024 * 1024;  // 4MB chunks
```

## 2. Core Data Structures

### 2.1 Analysis Results
```rust
struct ZipAnalysis {
    total_size: AtomicUsize,
    compression_ratio: RwLock<f64>,
    file_types: RwLock<HashMap<String, usize>>,
    compression_methods: HashMap<u16, usize>,
    file_paths: RwLock<Vec<String>>,
    total_compressed: u64,
    total_uncompressed: u64,
    file_count: usize,
}
```

### 2.2 ZIP Header
```rust
struct ZipHeader {
    compression_method: u16,
    compressed_size: u64,
    uncompressed_size: u64,
    file_name: String,
    is_encrypted: bool,
    crc32: u32,  // For data integrity
}

// Validation Strategy
- File-level validations in reader.rs
  * Check file count <= 65,535
  * Verify ZIP32 format
- Chunk-level validations in processor.rs
- ASCII filenames only
- Size < 4GB
- Basic compression methods only
```

## 3. Processing Strategy

### 3.1 End-First Reading
```rust
// Phase 1: End Scan
- Read last MAX_COMMENT_SIZE + MIN_EOCD_SIZE bytes
- Scan backwards for EOCD signature
- Handle ZIP file comments

// Phase 2: Central Directory
- Get CD offset and size from EOCD
- Validate CD location
- Read CD in one operation
- Process all entries sequentially
```

### 3.2 Progress Tracking
```rust
// Progress format
"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {bytes}/{total_bytes} ({eta}) [{:.1}% compressed] [ZIP entries: {msg}]"

// Entry progress
- Files processed
- Compression ratio
- Total bytes analyzed
```

### 3.3 Parallel Processing
```rust
// Thread pool configuration
rayon::ThreadPoolBuilder::new()
    .num_threads(num_cpus::get())
    .stack_size(8 * 1024 * 1024)
    .build()

// Cache-aligned chunk
#[repr(C, align(64))]
struct Chunk {
    data: Vec<u8>,
    offset: u64,
    size: usize,
}
```

## 4. Safety Requirements

### 4.1 Essential Validations
```rust
// File-level validations
- Check file count <= 65,535
- Verify ZIP32 format
- File size < 4GB
- ASCII filename check
- Basic compression methods only

// Chunk-level validations
- Signature verification
- Size validation
- CRC32 validation (optional)
```

### 4.2 Memory Safety
```rust
// Thread safety
- Cache-aligned chunks
- Thread-safe counters (AtomicUsize)
- Thread-safe collections (RwLock)
- Basic cleanup on drop
- Proper error propagation
- Resource cleanup on cancellation
```

## 5. Error Handling
```rust
// Specific error types with context
#[derive(Error)]
pub enum Error {
    #[error("ZIP format error: {0}")]
    Zip(String),
    #[error("IO error: {0}")]
    Io(String),
    #[error("Processing error: {0}")]
    Processing(String),
}

// Error context pattern
.map_err(|e| Error::Io(format!(
    "Failed to read metadata for {}: {}", 
    path.display(), 
    e
)))?
```

## 6. Testing Requirements

### 6.1 Essential Tests
```rust
#[tokio::test]
async fn test_resource_cleanup() {
    let dir = tempdir().unwrap();
    let path = dir.path().join("test.zip");
    {
        let reader = ZipReader::new(path.clone()).await.unwrap();
        // Reader dropped here, should cleanup
    }
    // Verify cleanup
}

#[test]
fn test_concurrent_processing() {
    let processor = Processor::new().unwrap();
    let data = Arc::new(vec![/* test data */]);
    let results = Arc::new(RwLock::new(ZipAnalysis::new()));
    
    // Test concurrent access
}

#[tokio::test]
async fn test_error_propagation() {
    // Test error handling
}
```

### 6.2 Error Tests
```rust
#[test]
fn test_error_propagation() {
    let dir = tempdir().unwrap();
    let path = dir.path().join("invalid.zip");
    
    std::fs::write(&path, b"not a zip file").unwrap();
    
    let result = ZipReader::new(path).await;
    assert!(matches!(result, Err(Error::Zip(_))));
}

#[test]
fn test_ownership_patterns() {
    // Test borrowing rules
    // Test lifetime constraints
    // Test mutability requirements
}

#[test]
fn test_stream_implementation() {
    // Test stream behavior
    // Test cancellation
    // Test error propagation
}
```

## 7. Stream Implementation Patterns
```rust
// Lifetime Management
pin_project! {
    struct ChunkStream<'a> {
        #[pin]
        reader: &'a mut ZipReader,  // Note lifetime
        buffer: Vec<u8>,
    }
}

impl<'a> Stream for ChunkStream<'a> {
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let mut this = self.project();  // Always mut
        // ...
    }
}

// Stream Creation Pattern
fn stream_chunks(&mut self) -> impl Stream<Item = Result<Chunk>> + '_ {
    let chunk_size = self.chunk_size;  // Cache before borrow
    ChunkStream {
        reader: self,
        buffer: vec![0; chunk_size],
    }
}
```

## 8. Resource Management
```rust
// File Handle Pattern
impl Drop for ZipReader {
    fn drop(&mut self) {
        if let Err(e) = futures::executor::block_on(self.file.sync_all()) {
            eprintln!("Error during file cleanup: {}", e);
        }
    }
}

// Arc/RwLock Pattern
let results = Arc::new(RwLock::new(ZipAnalysis::new()));
{
    let progress_tracker = Arc::clone(&results);
    // Use in limited scope
} // progress_tracker dropped here
```

## 9. Import Guidelines
```rust
// Essential imports
use futures::{Stream, Future};  // For async operations
use pin_project_lite::pin_project;
use std::task::{Context, Poll};
use std::sync::atomic::{AtomicUsize, Ordering};
use parking_lot::RwLock;
use thiserror::Error;

// Group imports by purpose
// Standard library
use std::sync::Arc;

// External crates - only what's used
use futures::StreamExt;
use rayon::ThreadPool;

// Internal modules
use crate::types::Result;
```

## 10. Development Strategy & Process

### 10.1 Pre-Implementation Gate
```bash
# MUST complete before writing any code:
- [ ] Create checklist from blueprint
- [ ] Document required traits and types
- [ ] Create error log template
- [ ] Setup validation workflow
```

### 10.2 Implementation Gate
```rust
// MUST follow this order:
1. Core types and constants
   pub const MAX_FILE_SIZE: u64 = 0xFFFFFFFF;
   pub struct ZipHeader { ... }

2. Error handling
   #[derive(Error)]
   pub enum Error { ... }

3. Trait implementations
   impl Stream for ChunkStream { ... }

4. Business logic
   pub fn process_chunk(...) { ... }
```

### 10.3 Validation Gate
```bash
# MUST run after each module:
cargo check              # Compile check
cargo clippy            # Linting
cargo test              # Unit tests
cargo fmt              # Formatting
```

### 10.4 Integration Gate
```bash
# MUST verify cross-module impacts:
- [ ] Check trait bounds
- [ ] Verify error propagation
- [ ] Test async flows
- [ ] Validate resource cleanup
```

### 10.5 Error Log Template
```markdown
# Module Implementation Status
## Current Changes
- [ ] List changes being made
- [ ] Document expected impacts

## Validation Status
- [ ] Cargo check passed
- [ ] Clippy warnings addressed
- [ ] Tests passing

## Cross-Module Impact
- [ ] List affected modules
- [ ] Document required updates
```

### 10.6 Change Management
```rust
// MUST document in error log:
- Before: Current implementation
- Change: What's being modified
- After: Expected result
- Impact: Cross-module effects
```

### 10.7 Review Process
```bash
# MUST verify before commit:
- [ ] Error log updated
- [ ] All gates passed
- [ ] Tests added/updated
- [ ] Documentation complete
```

## 11. Quality Assurance Checklist

### 11.1 Code Quality
```rust
// MUST verify:
- No unused imports
- Proper error handling
- Resource cleanup
- Documentation
```

### 11.2 Type Safety
```rust
// MUST check:
- Trait bounds complete
- Lifetime annotations
- Mutability requirements
- Type conversions
```

### 11.3 Resource Safety
```rust
// MUST validate:
- File handles cleaned up
- Memory properly managed
- Threads properly joined
- Cancellation handled
```

## 12. Mutability Patterns

### 12.1 Reader Pattern
```rust
// WRONG ‚ùå
let reader = ZipReader::new(path).await?;
let stream = reader.stream_chunks();  // Needs mut

// CORRECT ‚úÖ
let mut reader = ZipReader::new(path).await?;  // Declare as mut
let mut stream = reader.stream_chunks();  // Get mutable stream
```

### 12.2 Stream Creation
```rust
// WRONG ‚ùå
pub fn stream_chunks(&self) -> impl Stream<Item = Result<Chunk>> {
    // Can't mutate self
}

// CORRECT ‚úÖ
pub fn stream_chunks(&mut self) -> impl Stream<Item = Result<Chunk>> + '_ {
    // Can mutate self, explicit lifetime
}
```

### 12.3 Variable Declaration Rules
```rust
// Always declare variables that will be mutated as mut
let mut reader = /* initialization */;
let mut stream = /* initialization */;
let mut results = /* initialization */;

// Document mutability requirements in comments
/// Requires mutable reference for streaming
pub fn stream_chunks(&mut self) -> impl Stream
```

## 13. Type System Validation
```rust
// Always use this pattern for Stream implementations
pin_project! {
    struct ChunkStream<'a> {
        #[pin]
        reader: &'a mut ZipReader,  // Note lifetime
        buffer: Vec<u8>,
    }
}

impl<'a> Stream for ChunkStream<'a> {
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let mut this = self.project();  // Always mut
        // ...
    }
}
```

## 14. Common Pitfalls
### 14.1 Stream Implementation:
- Always use mut with project()
- Handle Pin correctly
- Proper lifetime annotations

### 14.2 Import Management:
- No wildcard imports (prelude::*)
- Remove unused imports
- Group imports logically

### 14.3 Ownership/Borrowing:
- Document lifetime requirements
- Clear ownership boundaries
- Explicit mutability

### 14.4 Async/Stream:
- Proper Future/Stream traits
- Handle Pin correctly
- Test cancellation

## 15. LLM Prompting Strategy
```prompt
1. Core Implementation:
   Implement [module] for ZIP analyzer with:
   - Essential types and traits
   - Error handling
   - Thread safety
   - No excess features
   Show me the code with:
   - All required imports
   - Complete type signatures
   - Error handling
   - Tests

2. Cross-Module Validation:
   Review this implementation for:
   1. Missing trait bounds
   2. Type conversion issues
   3. Error propagation
   4. Thread safety
   5. Resource cleanup
   Show all potential issues and fixes.

3. Integration Check:
   Analyze these modules together:
   - types.rs
   - reader.rs
   - processor.rs
   - main.rs
   Find:
   1. Missing dependencies
   2. Type mismatches
   3. Trait implementation gaps
   4. Resource handling issues
```

## 16. Ownership Rules
```rust
// Always document ownership requirements
struct Reader {
    // Owned fields
    file: File,            // Owns the file
    buffer: Vec<u8>,       // Owns the buffer
    
    // Reference fields
    config: &'a Config,    // Borrows configuration
}
```

## 17. Implementation Notes
```rust
// Cache values before borrowing
let config = self.get_config();
let size = self.get_size();

// Then create structures using borrowed self
StructWithBorrow {
    item: self,
    config,
    buffer: vec![0; size],
}
```

## 18. Variable Usage Patterns
```rust
// Time Measurement
// WRONG ‚ùå
let start_time = Instant::now();  // Unused

// CORRECT ‚úÖ
let start_time = Instant::now();
// ... code ...
let elapsed = start_time.elapsed();
// OR
let _start_time = Instant::now();  // Explicitly mark as unused
```

## 19. Pre-Commit Validation
```bash
# MUST run before commit:
cargo clippy -- -D warnings  # Treat warnings as errors
cargo check                  # Verify compilation
cargo test                   # Run tests
```

## 20. Essential Imports & Traits
```rust
// Async/Stream
use futures::{Stream, Future};  // For async operations
use pin_project_lite::pin_project;  // For stream implementation
use std::task::{Context, Poll};  // For async control

// Thread Safety
use std::sync::atomic::{AtomicUsize, Ordering};  // For counters
use parking_lot::RwLock;  // For shared state

// Error Handling
use thiserror::Error;  // For error types
impl From<std::io::Error> for Error { }  // For error conversion
```

## 21. Validation Patterns
```rust
// File Size
if metadata.len() > MAX_FILE_SIZE {
    return Err(Error::Zip("File too large (>4GB not supported)".into()));
}

// ZIP Signature
if &data[0..4] != b"PK\x03\x04" {
    return Err(Error::Zip("Invalid ZIP signature".into()));
}

// ASCII Filenames
if !file_name.is_ascii() {
    return None;  // Skip non-ASCII filenames
}
```

## 22. Resource Management Patterns
```rust
// File Handles
let file = File::open(&path).await
    .map_err(|e| Error::Io(format!("Failed to open: {}", e)))?;

// Memory
let chunk_size = self.chunk_size;
ChunkStream {
    reader: self,
    buffer: vec![0; chunk_size],
}

// Thread Pool
let thread_pool = rayon::ThreadPoolBuilder::new()
    .num_threads(num_cpus::get())
    .stack_size(8 * 1024 * 1024)
    .build()?;
```

## 23. Error Prevention Patterns

### 23.1 Arc/RwLock Pattern
```rust
// WRONG ‚ùå
let results_clone = Arc::clone(&results);
// Use throughout function scope
Arc::try_unwrap(results)?

// CORRECT ‚úÖ
let results = Arc::new(RwLock::new(ZipAnalysis::new()));
{
    let progress_tracker = Arc::clone(&results);
    // Use in limited scope
    // Progress tracking code...
} // progress_tracker dropped here
Arc::try_unwrap(results)?.into_inner()
```

### 23.2 Thread Pool Configuration
```rust
// WRONG ‚ùå
let mut builder = rayon::ThreadPoolBuilder::new();
if let Some(count) = threads {
    builder = builder.num_threads(count);
}
builder.build()?

// CORRECT ‚úÖ
rayon::ThreadPoolBuilder::new()
    .num_threads(threads.unwrap_or_else(num_cpus::get))
    .stack_size(8 * 1024 * 1024)
    .build()
    .map(|thread_pool| Self { thread_pool })
    .map_err(|e| Error::Processing(format!("Thread pool creation failed: {}", e)))
```

### 23.3 Error Context Pattern
```rust
// WRONG ‚ùå
.map_err(|e| Error::Io(e.to_string()))?

// CORRECT ‚úÖ
.map_err(|e| Error::Io(format!(
    "Failed to read metadata for {}: {}", 
    path.display(), 
    e
)))?
```

### 23.4 Resource Cleanup Pattern
```rust
// WRONG ‚ùå
impl Drop for ZipReader {
    fn drop(&mut self) {
        let _ = self.file.sync_all();  // Sync might fail silently
    }
}

// CORRECT ‚úÖ
impl Drop for ZipReader {
    fn drop(&mut self) {
        if let Err(e) = futures::executor::block_on(self.file.sync_all()) {
            eprintln!("Error during file cleanup: {}", e);
        }
    }
}
```

### 23.5 Progress Tracking Pattern
```rust
// WRONG ‚ùå
pb.set_position(current_size);  // Raw update

// CORRECT ‚úÖ
let current = progress_tracker.read();
pb.set_message(format!(
    "{} files, {:.1}% compressed",
    current.file_count(),
    current.get_compression_ratio() * 100.0
));
pb.set_position(current.total_size() as u64);
```

## 24. Development Process & Quality Gates üö¶

### 24.1 Pre-Implementation Gate
```bash
# MUST complete before writing any code:
- [ ] Create checklist from blueprint
- [ ] Document required traits and types
- [ ] Create error log template
- [ ] Setup validation workflow
```

### 24.2 Implementation Gate
```rust
// MUST follow this order:
1. Core types and constants
   pub const MAX_FILE_SIZE: u64 = 0xFFFFFFFF;
   pub struct ZipHeader { ... }

2. Error handling
   #[derive(Error)]
   pub enum Error { ... }

3. Trait implementations
   impl Stream for ChunkStream { ... }

4. Business logic
   pub fn process_chunk(...) { ... }
```

### 24.3 Validation Gate
```bash
# MUST run after each module:
cargo check              # Compile check
cargo clippy            # Linting
cargo test              # Unit tests
cargo fmt              # Formatting
```

### 24.4 Integration Gate
```bash
# MUST verify cross-module impacts:
- [ ] Check trait bounds
- [ ] Verify error propagation
- [ ] Test async flows
- [ ] Validate resource cleanup
```

### 24.5 Error Log Template
```markdown
# Module Implementation Status
## Current Changes
- [ ] List changes being made
- [ ] Document expected impacts

## Validation Status
- [ ] Cargo check passed
- [ ] Clippy warnings addressed
- [ ] Tests passing

## Cross-Module Impact
- [ ] List affected modules
- [ ] Document required updates
```

### 24.6 Change Management
```rust
// MUST document in error log:
- Before: Current implementation
- Change: What's being modified
- After: Expected result
- Impact: Cross-module effects
```

### 24.7 Review Process
```bash
# MUST verify before commit:
- [ ] Error log updated
- [ ] All gates passed
- [ ] Tests added/updated
- [ ] Documentation complete
```