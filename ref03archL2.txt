# ZIP Analyzer Implementation Blueprint - MVP Version üìù

## 1. ZIP Format Constants and Types
```rust
// Essential ZIP format signatures
const ZIP_LOCAL_HEADER_SIGNATURE: u32    = 0x04034b50;
const ZIP_CENTRAL_DIR_SIGNATURE: u32     = 0x02014b50;

// Basic compression methods
const STORED: u16 = 0;
const DEFLATED: u16 = 8;

// Size limits for v1.0
const MAX_FILE_SIZE: u64 = 0xFFFFFFFF;  // 4GB limit
```

## 2. Core Data Structures

### 2.1 ZIP Header
```rust
struct ZipHeader {
    compression_method: u16,
    compressed_size: u64,
    uncompressed_size: u64,
    file_name: String,
    is_encrypted: bool,
    crc32: u32,  // Added for data integrity
}

// Validation Strategy
- File-level validations in reader.rs
- Chunk-level validations in processor.rs
- ASCII filenames only
- Size < 4GB
- Basic compression methods only
```

### 2.2 Analysis Results
```rust
struct ZipAnalysis {
    total_size: AtomicUsize,
    compression_ratio: RwLock<f64>,
    file_types: HashMap<String, usize>,
    compression_methods: HashMap<u16, usize>,
}
```

## 3. Processing Pipeline

### 3.1 Chunk Processing
```rust
// Optimal chunk size
const CHUNK_SIZE: usize = 256 * 1024;  // 256KB

// Cache-aligned chunk
#[repr(C, align(64))]
struct Chunk {
    data: Vec<u8>,
    offset: u64,
    size: usize,
}
```

### 3.2 Parallel Processing
```rust
// Thread pool configuration
rayon::ThreadPoolBuilder::new()
    .num_threads(num_cpus::get())
    .stack_size(8 * 1024 * 1024)
    .build()
```

## 4. Safety Requirements

### 4.1 Essential Validations
- ZIP signature check (in processor.rs)
- Basic size validation (in reader.rs)
- ASCII filename check (in processor.rs)
- 4GB file size limit (in reader.rs)
- CRC32 validation (optional, for data integrity)

### 4.2 Memory Safety
- Cache-aligned chunks
- Thread-safe counters
- Basic cleanup on drop
- Proper error propagation
- Resource cleanup on cancellation

## 5. Progress Tracking
```rust
"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {bytes}/{total_bytes} ({eta}) [{:.1}% compressed] [ZIP entries: {msg}]"
```

## 6. Testing Requirements

### 6.1 Essential Tests
- Basic ZIP parsing
- Compression methods
- Thread safety
- Progress tracking

### 6.2 Performance Tests
- Parallel processing
- Memory alignment
- Basic error handling

=== MVP Scope ===
Included:
+ Basic ZIP parsing
+ Thread safety
+ Progress tracking
+ Error handling
+ Memory safety basics
+ ASCII filename support
+ Common compression methods

Deferred:
- ZIP64 support (>4GB)
- Unicode paths
- Advanced CRC32 validation
- Memory leak prevention in edge cases
- Advanced compression methods

=== Backlog Items ===
## Future Improvements üîÑ
1. Memory Optimizations:
   - Remove crc32 field from ZipHeader
   - Optimize memory allocations
   - Reduce cache line pollution
   - Streamline thread pool configuration

2. Code Cleanup:
   - Remove unused imports
   - Simplify error variants
   - Document future expansion points
   - Clean up test cases

3. Performance Enhancements:
   - Optimize thread pool usage
   - Improve synchronization
   - Better CPU cache utilization
   - Streamline chunk processing

4. Error Handling:
   - More specific error messages
   - Better ZIP format validation
   - Improved error propagation
   - Cleaner error variants

## Notes üìù
- Implementation includes benign extras for better maintainability
- CRC32 support ready for future use
- Validation split across components for better separation of concerns
- Error handling distributed appropriately
- Progress tracking optimized for readability

=== Change Log ===
Modified:
* Simplified ZIP format handling
* Focused on essential features
* Added size limits
* Streamlined error handling
Added:
+ Backlog section for future improvements
+ Documentation of technical debt
+ Performance optimization notes
+ Cleanup recommendations

## Implementation Notes üìù
- Current implementation exceeds MVP in good ways:
  * Better error detection with CRC32
  * Cleaner validation separation
  * More maintainable structure
  * Future-ready features
- No performance impact from extras
- Better maintainability than strict MVP
- Ready for future enhancements

=== Development Strategy & Process ===

## Type System Validation üîç
1. Pin and Project:
   ```rust
   // Always use this pattern for Stream implementations
   pin_project! {
       struct ChunkStream<'a> {
           #[pin]
           reader: &'a mut ZipReader,  // Note lifetime
           buffer: Vec<u8>,
       }
   }

   impl<'a> Stream for ChunkStream<'a> {
       fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
           let mut this = self.project();  // Always mut
           // ...
       }
   }
   ```

2. Import Management:
   ```rust
   // Required imports section in each file
   mod types {
       // Essential imports only
       use std::sync::atomic::{AtomicUsize, Ordering};
       use parking_lot::RwLock;
       // No unused imports
   }
   ```

## Code Quality Checks üõ°Ô∏è
1. Pre-commit Checks:
   ```bash
   # Must run before any commit:
   cargo check
   cargo clippy -- -D warnings  # Treat warnings as errors
   cargo fmt -- --check
   cargo test
   ```

2. Module Dependencies:
   ```rust
   // Document required features
   #[cfg(feature = "async")]
   use tokio;
   
   #[cfg(feature = "parallel")]
   use rayon;
   ```

## Error Prevention Patterns üìã
1. Ownership Rules:
   ```rust
   // Always document ownership requirements
   struct Reader {
       // Owned fields
       file: File,            // Owns the file
       buffer: Vec<u8>,       // Owns the buffer
       
       // Reference fields
       config: &'a Config,    // Borrows configuration
   }
   ```

2. Mutability Guidelines:
   ```rust
   // Always be explicit about mutability
   impl<'a> Stream for DataStream<'a> {
       fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
           let mut this = self.project();  // Always mut for project()
           // ...
       }
   }
   ```

## Implementation Checklist ‚úÖ
1. Before Code:
   - [ ] Review blueprint requirements
   - [ ] List required traits and types
   - [ ] Plan error handling strategy
   - [ ] Design thread safety approach

2. During Implementation:
   - [ ] Start with core types
   - [ ] Add essential traits
   - [ ] Implement error handling
   - [ ] Add thread safety
   - [ ] Write basic tests

3. After Each Module:
   - [ ] Run cargo check
   - [ ] Run clippy
   - [ ] Run tests
   - [ ] Verify cross-module impacts
   - [ ] Check resource cleanup

4. Final Integration:
   - [ ] Verify all trait bounds
   - [ ] Check error conversions
   - [ ] Test thread safety
   - [ ] Validate resource handling
   - [ ] Run full test suite

Add:
- [ ] Verify all imports are used
- [ ] Check Pin/Project usage
- [ ] Validate mutability requirements
- [ ] Test async/stream implementations
- [ ] Run clippy with warnings as errors

## Common Pitfalls üö´
1. Stream Implementation:
   - Always use mut with project()
   - Handle Pin correctly
   - Proper lifetime annotations

2. Import Management:
   - No wildcard imports (prelude::*)
   - Remove unused imports
   - Group imports logically

3. Ownership/Borrowing:
   - Document lifetime requirements
   - Clear ownership boundaries
   - Explicit mutability

4. Async/Stream:
   - Proper Future/Stream traits
   - Handle Pin correctly
   - Test cancellation

## LLM Prompting Strategy ü§ñ
1. Core Implementation:
   ```prompt
   Implement [module] for ZIP analyzer with:
   - Essential types and traits
   - Error handling
   - Thread safety
   - No excess features
   Show me the code with:
   - All required imports
   - Complete type signatures
   - Error handling
   - Tests
   ```

2. Cross-Module Validation:
   ```prompt
   Review this implementation for:
   1. Missing trait bounds
   2. Type conversion issues
   3. Error propagation
   4. Thread safety
   5. Resource cleanup
   Show all potential issues and fixes.
   ```

3. Integration Check:
   ```prompt
   Analyze these modules together:
   - types.rs
   - reader.rs
   - processor.rs
   - main.rs
   Find:
   1. Missing dependencies
   2. Type mismatches
   3. Trait implementation gaps
   4. Resource handling issues
   ```

## Testing Requirements
[Previous testing sections...]

Add:
```rust
#[test]
fn test_stream_implementation() {
    // Test stream behavior
    // Test cancellation
    // Test error propagation
}

#[test]
fn test_ownership_patterns() {
    // Test borrowing rules
    // Test lifetime constraints
    // Test mutability requirements
}
```

## Stream Implementation Patterns üîç
1. Lifetime Management:
   ```rust
   // WRONG ‚ùå
   pub fn stream_chunks(&mut self) -> impl Stream<Item = Result<Chunk>> {
       ChunkStream { reader: self, ... }
   }

   // CORRECT ‚úÖ
   pub fn stream_chunks(&mut self) -> impl Stream<Item = Result<Chunk>> + '_ {
       let chunk_size = self.chunk_size;  // Get size before borrow
       ChunkStream {
           reader: self,
           buffer: vec![0; chunk_size],
       }
   }
   ```

2. Import Guidelines:
   ```rust
   // WRONG ‚ùå
   use futures::Future;  // Don't import traits not directly used
   use rayon::ThreadPoolBuilder;  // Don't import if using through thread_pool

   // CORRECT ‚úÖ
   use futures::StreamExt;  // Only import what's used
   use rayon::ThreadPool;   // Direct type usage
   ```

3. Borrowing Rules:
   ```rust
   // WRONG ‚ùå
   buffer: vec![0; self.chunk_size],  // Uses self after borrow

   // CORRECT ‚úÖ
   let size = self.chunk_size;        // Cache before borrow
   buffer: vec![0; size],             // Use cached value
   ```

## Error Prevention Patterns üìã
1. Lifetime Annotations:
   ```rust
   // Always be explicit with lifetimes in streams
   pub fn stream_chunks(&mut self) -> impl Stream<Item = Result<Chunk>> + '_ {
       // Implementation
   }
   ```

2. Borrow Checker Rules:
   ```rust
   // Get all values needed before borrowing
   let config = self.get_config();
   let size = self.get_size();
   
   // Then create structures using borrowed self
   StructWithBorrow {
       item: self,
       config,
       buffer: vec![0; size],
   }
   ```

3. Import Management:
   ```rust
   // Group imports by purpose
   // Standard library
   use std::sync::Arc;
   
   // External crates - only what's used
   use futures::StreamExt;
   use rayon::ThreadPool;
   
   // Internal modules
   use crate::types::Result;
   ```

## Implementation Checklist ‚úÖ
Add:
- [ ] Verify lifetime annotations on streams
- [ ] Check borrow checker patterns
- [ ] Validate import usage
- [ ] Test with clippy warnings as errors

## Common Pitfalls üö´
Add:
1. Stream Lifetime Issues:
   - Missing lifetime bounds
   - Hidden type captures
   - Improper borrow patterns

2. Import Issues:
   - Unused trait imports
   - Over-generic imports
   - Missing direct type imports

3. Borrow Checker:
   - Using self after borrow
   - Not caching needed values
   - Complex borrowing patterns

## Mutability Patterns üîí
1. Reader Pattern:
   ```rust
   // WRONG ‚ùå
   let reader = ZipReader::new(path).await?;
   let stream = reader.stream_chunks();  // Needs mut

   // CORRECT ‚úÖ
   let mut reader = ZipReader::new(path).await?;  // Declare as mut
   let mut stream = reader.stream_chunks();  // Get mutable stream
   ```

2. Stream Creation:
   ```rust
   // WRONG ‚ùå
   pub fn stream_chunks(&self) -> impl Stream<Item = Result<Chunk>> {
       // Can't mutate self
   }

   // CORRECT ‚úÖ
   pub fn stream_chunks(&mut self) -> impl Stream<Item = Result<Chunk>> + '_ {
       // Can mutate self, explicit lifetime
   }
   ```

3. Variable Declaration Rules:
   ```rust
   // Always declare variables that will be mutated as mut
   let mut reader = /* initialization */;
   let mut stream = /* initialization */;
   let mut results = /* initialization */;

   // Document mutability requirements in comments
   /// Requires mutable reference for streaming
   pub fn stream_chunks(&mut self) -> impl Stream
   ```

## Common Mutability Pitfalls üö´
1. Stream Creation:
   - Always declare stream source as mut
   - Always declare stream variable as mut
   - Use explicit lifetime bounds

2. Async Operations:
   - Mark async functions that need mutation with &mut self
   - Declare futures as mut when needed
   - Handle Pin<&mut Self> correctly

3. Resource Management:
   - Declare resource handles as mut when needed
   - Document mutability requirements
   - Use RwLock for shared mutable state

## Implementation Checklist ‚úÖ
Add:
- [ ] Check all stream source declarations
- [ ] Verify mut declarations
- [ ] Validate lifetime bounds
- [ ] Document mutability requirements

## Error Prevention Patterns üìã
Add:
1. Mutability Guidelines:
   - Always declare stream sources as mut
   - Always declare stream variables as mut
   - Document mutability in comments

2. Resource Patterns:
   - Use mut for file handles
   - Use mut for streams
   - Use mut for buffers

3. Testing Requirements:
   ```rust
   #[test]
   fn test_mutability_patterns() {
       let mut reader = Reader::new();  // Test mut declaration
       let mut stream = reader.get_stream();  // Test mut stream
       // Test usage...
   }
   ```

## Development Process & Quality Gates üö¶

1. Pre-Implementation Gate:
   ```bash
   # MUST complete before writing any code:
   - [ ] Create checklist from blueprint
   - [ ] Document required traits and types
   - [ ] Create error log template
   - [ ] Setup validation workflow
   ```

2. Implementation Gate:
   ```rust
   // MUST follow this order:
   1. Core types and constants
      pub const MAX_FILE_SIZE: u64 = 0xFFFFFFFF;
      pub struct ZipHeader { ... }

   2. Error handling
      #[derive(Error)]
      pub enum Error { ... }

   3. Trait implementations
      impl Stream for ChunkStream { ... }

   4. Business logic
      pub fn process_chunk(...) { ... }
   ```

3. Validation Gate:
   ```bash
   # MUST run after each module:
   cargo check              # Compile check
   cargo clippy            # Linting
   cargo test              # Unit tests
   cargo fmt              # Formatting
   ```

4. Integration Gate:
   ```bash
   # MUST verify cross-module impacts:
   - [ ] Check trait bounds
   - [ ] Verify error propagation
   - [ ] Test async flows
   - [ ] Validate resource cleanup
   ```

## Error Prevention Workflow üîÑ

1. Error Log Template:
   ```markdown
   # Module Implementation Status
   ## Current Changes
   - [ ] List changes being made
   - [ ] Document expected impacts
   
   ## Validation Status
   - [ ] Cargo check passed
   - [ ] Clippy warnings addressed
   - [ ] Tests passing
   
   ## Cross-Module Impact
   - [ ] List affected modules
   - [ ] Document required updates
   ```

2. Change Management:
   ```rust
   // MUST document in error log:
   - Before: Current implementation
   - Change: What's being modified
   - After: Expected result
   - Impact: Cross-module effects
   ```

3. Review Process:
   ```bash
   # MUST verify before commit:
   - [ ] Error log updated
   - [ ] All gates passed
   - [ ] Tests added/updated
   - [ ] Documentation complete
   ```

## Quality Assurance Checklist ‚úÖ

1. Code Quality:
   ```rust
   // MUST verify:
   - No unused imports
   - Proper error handling
   - Resource cleanup
   - Documentation
   ```

2. Type Safety:
   ```rust
   // MUST check:
   - Trait bounds complete
   - Lifetime annotations
   - Mutability requirements
   - Type conversions
   ```

3. Resource Safety:
   ```rust
   // MUST validate:
   - File handles cleaned up
   - Memory properly managed
   - Threads properly joined
   - Cancellation handled
   ```